use std::{
    env,
    fs,
    path::PathBuf,
};

use serde::Deserialize;

#[derive(Debug, Deserialize)]
struct DictionaryJson {
    name: String,
    marker_size: usize,
    max_correction_bits: u8,
    codes: Vec<String>,
}

fn main() {
    println!("cargo:rerun-if-changed=build.rs");

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR"));
    let data_dir = manifest_dir.join("data");

    let mut dicts: Vec<(String, PathBuf)> = Vec::new();

    if data_dir.exists() {
        for entry in fs::read_dir(&data_dir).expect("read_dir(data)") {
            let entry = entry.expect("dir entry");
            let path = entry.path();
            if !path.is_file() {
                continue;
            }
            let Some(fname) = path.file_name().and_then(|s| s.to_str()) else {
                continue;
            };
            if !fname.ends_with("_CODES.json") {
                continue;
            }
            let dict_name = fname.trim_end_matches("_CODES.json").to_string();
            dicts.push((dict_name, path));
        }
    }

    dicts.sort_by(|a, b| a.0.cmp(&b.0));

    // Ensure rebuild when any dict changes.
    for (_, path) in &dicts {
        println!("cargo:rerun-if-changed={}", path.display());
    }

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR"));
    let out_path = out_dir.join("builtins.rs");

    let mut out = String::new();
    out.push_str("// @generated by calib-targets-aruco/build.rs\n");
    out.push_str("use super::Dictionary;\n\n");

    out.push_str("pub const BUILTIN_DICTIONARY_NAMES: &[&str] = &[\n");
    for (name, _) in &dicts {
        out.push_str(&format!("    \"{name}\",\n"));
    }
    out.push_str("];\n\n");

    // Emit each dictionary as a static codes slice + a static Dictionary.
    for (name, path) in &dicts {
        let raw = fs::read_to_string(path).expect("read dict json");
        let parsed: DictionaryJson = serde_json::from_str(&raw).expect("parse dict json");

        if parsed.name != *name {
            panic!(
                "dictionary name mismatch: file stem={name} json.name={}",
                parsed.name
            );
        }

        let n = parsed.marker_size;
        if !(3..=8).contains(&n) {
            panic!("{name}: marker_size {n} is unsupported (expected 3..=8)");
        }
        let bit_count = n * n;
        if bit_count > 64 {
            panic!("{name}: marker_size {n} implies {bit_count} bits > 64");
        }

        let mut codes: Vec<u64> = Vec::with_capacity(parsed.codes.len());
        for (idx, s) in parsed.codes.iter().enumerate() {
            let stripped = s
                .strip_prefix("0x")
                .or_else(|| s.strip_prefix("0X"))
                .unwrap_or(s.as_str());
            let v = u64::from_str_radix(stripped, 16)
                .unwrap_or_else(|_| panic!("{name}: invalid hex code at index {idx}: {s}"));
            codes.push(v);
        }

        // Build safe Rust identifiers.
        let ident = sanitize_ident(name);
        let codes_ident = format!("{ident}_CODES");

        out.push_str(&format!(
            "pub static {codes_ident}: &[u64] = &[\n"
        ));
        for v in &codes {
            out.push_str(&format!("    0x{v:x},\n"));
        }
        out.push_str("];\n\n");

        out.push_str(&format!(
            "pub static {ident}: Dictionary = Dictionary {{\n"
        ));
        out.push_str(&format!("    name: \"{name}\",\n"));
        out.push_str(&format!("    marker_size: {n},\n"));
        out.push_str(&format!(
            "    max_correction_bits: {},\n",
            parsed.max_correction_bits
        ));
        out.push_str(&format!("    codes: {codes_ident},\n"));
        out.push_str("};\n\n");
    }

    // Lookup by name.
    out.push_str("pub fn builtin_dictionary(name: &str) -> Option<Dictionary> {\n");
    out.push_str("    Some(match name {\n");
    for (name, _) in &dicts {
        let ident = sanitize_ident(name);
        out.push_str(&format!("        \"{name}\" => {ident},\n"));
    }
    out.push_str("        _ => return None,\n");
    out.push_str("    })\n");
    out.push_str("}\n\n");

    fs::write(&out_path, out).expect("write builtins.rs");
}

fn sanitize_ident(name: &str) -> String {
    // All our dict names are already valid Rust identifiers (DICT_..., APRILTAG_...).
    // Still, keep this conservative: map non [A-Za-z0-9_] to underscores.
    let mut out = String::with_capacity(name.len());
    for ch in name.chars() {
        if ch.is_ascii_alphanumeric() || ch == '_' {
            out.push(ch);
        } else {
            out.push('_');
        }
    }
    if out
        .chars()
        .next()
        .is_some_and(|c| c.is_ascii_digit())
    {
        out.insert(0, '_');
    }
    out
}
